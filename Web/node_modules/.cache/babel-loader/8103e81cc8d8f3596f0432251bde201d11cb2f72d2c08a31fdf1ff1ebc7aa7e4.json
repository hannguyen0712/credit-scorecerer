{"ast":null,"code":"import { GoogleGenerativeAI } from '@google/generative-ai';\nclass GeminiService {\n  // 5 minutes\n\n  constructor() {\n    this.genAI = null;\n    this.model = null;\n    this.responseCache = new Map();\n    this.CACHE_EXPIRY = 5 * 60 * 1000;\n    const apiKey = process.env.REACT_APP_GEMINI_API_KEY;\n    if (apiKey && apiKey !== 'your_gemini_api_key_here') {\n      this.genAI = new GoogleGenerativeAI(apiKey);\n      // Pre-initialize the model for better performance\n      this.model = this.genAI.getGenerativeModel({\n        model: 'gemini-2.5-flash',\n        generationConfig: {\n          maxOutputTokens: 1000,\n          // Limit response length for faster responses\n          temperature: 0.3,\n          // Lower temperature for more consistent, faster responses\n          topP: 0.8,\n          topK: 40\n        }\n      });\n    } else {\n      console.warn('Gemini API key not set or is placeholder. Using mock responses.');\n    }\n  }\n  async getPurchaseRecommendation(request, userCards) {\n    try {\n      console.log('GeminiService: Starting purchase consultation...');\n\n      // Create cache key for similar requests\n      const cacheKey = this.createCacheKey(request, userCards);\n      const cachedResponse = this.getCachedResponse(cacheKey);\n      if (cachedResponse) {\n        console.log('Returning cached response');\n        return cachedResponse;\n      }\n      if (this.model) {\n        console.log('Using Gemini API...');\n\n        // Use optimized prompt\n        const prompt = this.buildOptimizedConsultationPrompt(request, userCards);\n        console.log('Sending optimized prompt to Gemini...');\n        const startTime = Date.now();\n        const result = await this.model.generateContent(prompt);\n        const response = await result.response;\n        const text = response.text();\n        const duration = Date.now() - startTime;\n        console.log(`Gemini response received in ${duration}ms`);\n        const parsedResponse = this.parseAIResponse(text, userCards);\n\n        // Cache the response\n        this.cacheResponse(cacheKey, parsedResponse);\n        return parsedResponse;\n      } else {\n        console.log('Using mock response...');\n        return this.getMockPurchaseRecommendation(request, userCards);\n      }\n    } catch (error) {\n      console.error('Error getting AI recommendation:', error);\n      // Fallback to mock response on error\n      console.log('Falling back to mock response...');\n      return this.getMockPurchaseRecommendation(request, userCards);\n    }\n  }\n  buildOptimizedConsultationPrompt(request, userCards) {\n    // Optimized prompt - shorter and more focused\n    const cardsSummary = userCards.map(card => `${card.name}: $${card.currentBalance}/${card.creditLimit} (${(card.currentBalance / card.creditLimit * 100).toFixed(1)}%), ${card.rewards.rate}% ${card.rewards.type}, ${card.interestRate}% APR`).join(' | ');\n    return `Credit advisor: User has cards: ${cardsSummary}. \nPurchase: $${request.purchaseAmount} ${request.purchaseCategory} - ${request.description}\n${request.preferredCard ? `Preferred: ${request.preferredCard}` : ''}\n\nRespond with JSON only:\n{\n  \"recommendation\": {\n    \"recommendedCard\": \"card name\",\n    \"reasoning\": \"Brief reasoning with numbers\",\n    \"creditImpact\": \"positive|neutral|negative\", \n    \"impactExplanation\": \"brief impact\"\n  },\n  \"alternatives\": [{\"cardId\": \"id\", \"cardName\": \"name\", \"pros\": [\"pro\"], \"cons\": [\"con\"]}],\n  \"tips\": [\"tip1\", \"tip2\"]\n}`;\n  }\n  buildConsultationPrompt(request, userCards) {\n    const cardsInfo = userCards.map(card => `Card: ${card.name} (${card.issuer})\n- Credit Limit: $${card.creditLimit.toLocaleString()}\n- Current Balance: $${card.currentBalance.toLocaleString()}\n- Available Credit: $${card.availableCredit.toLocaleString()}\n- Interest Rate: ${card.interestRate}%\n- Minimum Payment: $${card.minimumPayment}\n- Rewards: ${card.rewards.type} at ${card.rewards.rate}% rate\n- Utilization: ${(card.currentBalance / card.creditLimit * 100).toFixed(1)}%\n- Due Date: ${card.dueDate}\n- Last Payment: ${card.lastPaymentDate || 'No recent payments'}\n- Last Payment Amount: ${card.lastPaymentAmount ? `$${card.lastPaymentAmount}` : 'N/A'}`).join('\\n\\n');\n    return `You are a direct, no-nonsense financial advisor helping with credit card purchase decisions. \n\nUser's Credit Cards with complete details:\n${cardsInfo}\n\nPurchase Details:\n- Amount: $${request.purchaseAmount}\n- Category: ${request.purchaseCategory}\n- Description: ${request.description}\n${request.preferredCard ? `- Preferred Card: ${request.preferredCard}` : ''}\n\nProvide a recommendation in the following JSON format with concrete, actionable guidance:\n{\n  \"recommendation\": {\n    \"recommendedCard\": \"Card name\",\n    \"reasoning\": \"Single paragraph with specific numbers, exact payment amounts, reward calculations, interest savings, credit score impact numbers, and concrete timeline recommendations. Be direct and practical.\",\n    \"creditImpact\": \"positive|neutral|negative\",\n    \"impactExplanation\": \"Specific percentage impact on credit score with exact numbers and timeline\"\n  },\n  \"alternatives\": [\n    {\n      \"cardId\": \"card-id\",\n      \"cardName\": \"Card name\",\n      \"pros\": [\"specific advantage with numbers\"],\n      \"cons\": [\"specific disadvantage with numbers\"]\n    }\n  ],\n  \"tips\": [\n    \"Concrete tip with specific numbers and actionable steps\",\n    \"Another concrete tip with exact amounts and timeline\"\n  ]\n}\n\nFocus on:\n- Specific utilization targets with exact percentages\n- Exact payment amounts and interest savings calculations\n- Reward optimization strategies with specific dollar amounts\n- Credit score impact numbers with concrete timeline\n- Payment due dates and cash flow optimization\n- Concrete timeline recommendations\n\nProvide practical, actionable advice with specific numbers and calculations.`;\n  }\n  parseAIResponse(responseText, userCards) {\n    try {\n      var _parsed$recommendatio, _parsed$recommendatio2, _parsed$recommendatio3, _parsed$recommendatio4, _parsed$alternatives;\n      // Extract JSON from the response\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('No JSON found in response');\n      }\n      const parsed = JSON.parse(jsonMatch[0]);\n\n      // Validate and map the response\n      return {\n        recommendation: {\n          recommendedCard: ((_parsed$recommendatio = parsed.recommendation) === null || _parsed$recommendatio === void 0 ? void 0 : _parsed$recommendatio.recommendedCard) || 'Unknown',\n          reasoning: ((_parsed$recommendatio2 = parsed.recommendation) === null || _parsed$recommendatio2 === void 0 ? void 0 : _parsed$recommendatio2.reasoning) || 'No reasoning provided',\n          creditImpact: ((_parsed$recommendatio3 = parsed.recommendation) === null || _parsed$recommendatio3 === void 0 ? void 0 : _parsed$recommendatio3.creditImpact) || 'neutral',\n          impactExplanation: ((_parsed$recommendatio4 = parsed.recommendation) === null || _parsed$recommendatio4 === void 0 ? void 0 : _parsed$recommendatio4.impactExplanation) || 'No impact explanation'\n        },\n        alternatives: ((_parsed$alternatives = parsed.alternatives) === null || _parsed$alternatives === void 0 ? void 0 : _parsed$alternatives.map(alt => ({\n          cardId: alt.cardId || '',\n          cardName: alt.cardName || 'Unknown Card',\n          pros: alt.pros || [],\n          cons: alt.cons || []\n        }))) || [],\n        tips: parsed.tips || []\n      };\n    } catch (error) {\n      var _userCards$;\n      console.error('Error parsing AI response:', error);\n      // Return a fallback response\n      return {\n        recommendation: {\n          recommendedCard: ((_userCards$ = userCards[0]) === null || _userCards$ === void 0 ? void 0 : _userCards$.name) || 'Unknown',\n          reasoning: 'Unable to parse AI response. Please try again.',\n          creditImpact: 'neutral',\n          impactExplanation: 'Unable to determine impact.'\n        },\n        alternatives: [],\n        tips: ['Consider your credit utilization when making purchases.', 'Pay off balances in full when possible.']\n      };\n    }\n  }\n  async getGeneralCreditAdvice(question, userCards) {\n    try {\n      console.log('GeminiService: Starting API call...');\n\n      // Create cache key for similar questions\n      const cacheKey = `advice_${question.toLowerCase().replace(/[^a-z0-9]/g, '')}`;\n      const cachedResponse = this.getCachedResponse(cacheKey);\n      if (cachedResponse) {\n        console.log('Returning cached advice response');\n        return cachedResponse;\n      }\n      if (this.model) {\n        console.log('Using Gemini API...');\n\n        // Optimized prompt - shorter and more direct\n        const cardsSummary = userCards.map(card => `${card.name}: ${(card.currentBalance / card.creditLimit * 100).toFixed(1)}% util`).join(', ');\n        const prompt = `Financial advisor. Cards: ${cardsSummary}. Question: ${question}. Give concise, actionable advice in 1-2 sentences.`;\n        console.log('Sending optimized prompt to Gemini...');\n        const startTime = Date.now();\n        const result = await this.model.generateContent(prompt);\n        const response = await result.response;\n        const text = response.text();\n        const duration = Date.now() - startTime;\n        console.log(`Gemini advice received in ${duration}ms`);\n\n        // Cache the response\n        this.cacheResponse(cacheKey, text);\n        return text;\n      } else {\n        console.log('Using mock response...');\n        return this.getMockGeneralAdvice(question, userCards);\n      }\n    } catch (error) {\n      console.error('Error getting general advice:', error);\n      // Fallback to mock response\n      console.log('Falling back to mock response...');\n      return this.getMockGeneralAdvice(question, userCards);\n    }\n  }\n  getMockPurchaseRecommendation(request, userCards) {\n    // Find the best card for the purchase based on rewards and utilization\n    const bestCard = userCards.reduce((best, card) => {\n      const bestUtilization = best.currentBalance / best.creditLimit;\n      const currentUtilization = card.currentBalance / card.creditLimit;\n\n      // Prefer cards with lower utilization and higher rewards\n      if (currentUtilization < bestUtilization || currentUtilization === bestUtilization && card.rewards.rate > best.rewards.rate) {\n        return card;\n      }\n      return best;\n    });\n    const utilizationAfterPurchase = (bestCard.currentBalance + request.purchaseAmount) / bestCard.creditLimit;\n    const creditImpact = utilizationAfterPurchase > 0.3 ? 'negative' : utilizationAfterPurchase > 0.1 ? 'neutral' : 'positive';\n    return {\n      recommendation: {\n        recommendedCard: bestCard.name,\n        reasoning: `Based on your current credit utilization and rewards structure, I recommend using your ${bestCard.name} for this $${request.purchaseAmount} ${request.purchaseCategory} purchase. This card offers ${bestCard.rewards.rate}% ${bestCard.rewards.type} rewards, and your utilization will remain at ${(utilizationAfterPurchase * 100).toFixed(1)}% after this purchase. Pay off the balance within the grace period to avoid interest charges of $${(request.purchaseAmount * bestCard.interestRate / 100 / 12).toFixed(2)} per month.`,\n        creditImpact,\n        impactExplanation: creditImpact === 'positive' ? 'This purchase will help maintain low utilization, potentially improving your credit score' : creditImpact === 'negative' ? 'This purchase will increase your utilization above 30%, which may negatively impact your credit score' : 'This purchase will have minimal impact on your credit score'\n      },\n      alternatives: userCards.filter(card => card.id !== bestCard.id).map(card => ({\n        cardId: card.id,\n        cardName: card.name,\n        pros: [`${card.rewards.rate}% ${card.rewards.type} rewards`, `Current utilization: ${(card.currentBalance / card.creditLimit * 100).toFixed(1)}%`],\n        cons: [card.interestRate > bestCard.interestRate ? `Higher interest rate (${card.interestRate}%)` : '', card.currentBalance > bestCard.currentBalance ? 'Higher current balance' : ''].filter(Boolean)\n      })),\n      tips: [`Pay off this purchase by ${bestCard.dueDate} to avoid interest charges`, `Consider setting up automatic payments to avoid late fees`, `Monitor your credit utilization to keep it below 30% for optimal credit score impact`]\n    };\n  }\n  getMockGeneralAdvice(question, userCards) {\n    const totalUtilization = userCards.reduce((sum, card) => {\n      return sum + card.currentBalance / card.creditLimit;\n    }, 0) / userCards.length;\n    const avgUtilization = (totalUtilization * 100).toFixed(1);\n    if (question.toLowerCase().includes('utilization') || question.toLowerCase().includes('credit score')) {\n      return `Your current average credit utilization is ${avgUtilization}%. To improve your credit score, aim to keep utilization below 30%. Consider paying down your highest balance cards first, and avoid making large purchases that would push your utilization above this threshold. Your credit score can improve significantly by maintaining low utilization over time.`;\n    }\n    if (question.toLowerCase().includes('payment') || question.toLowerCase().includes('pay off')) {\n      return `Focus on paying off your highest interest rate cards first to minimize interest charges. Set up automatic payments for at least the minimum amount to avoid late fees, which can hurt your credit score. If possible, pay more than the minimum to reduce your principal balance faster.`;\n    }\n    if (question.toLowerCase().includes('reward') || question.toLowerCase().includes('cashback')) {\n      return `Your cards offer different reward structures. Use your highest reward rate card for purchases in categories where it offers the most value. Remember that rewards are only beneficial if you pay off your balance in full each month to avoid interest charges that could exceed the reward value.`;\n    }\n\n    // Default advice\n    const utilizationNum = parseFloat(avgUtilization);\n    return `Based on your current credit card situation, I recommend focusing on maintaining low credit utilization (below 30%), paying off high-interest balances first, and making payments on time. Your average utilization of ${avgUtilization}% ${utilizationNum > 30 ? 'could be improved' : 'is in a good range'}. Consider setting up automatic payments and monitoring your credit score regularly for optimal financial health.`;\n  }\n\n  // Caching utilities\n  createCacheKey(request, userCards) {\n    const cardsKey = userCards.map(card => `${card.id}_${card.currentBalance}_${card.creditLimit}`).join('|');\n    return `purchase_${request.purchaseAmount}_${request.purchaseCategory}_${cardsKey}`;\n  }\n  getCachedResponse(key) {\n    const cached = this.responseCache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.CACHE_EXPIRY) {\n      return cached.data;\n    }\n    // Remove expired cache\n    if (cached) {\n      this.responseCache.delete(key);\n    }\n    return null;\n  }\n  cacheResponse(key, data) {\n    this.responseCache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n\n    // Clean up old cache entries if map gets too large\n    if (this.responseCache.size > 50) {\n      const oldestKey = this.responseCache.keys().next().value;\n      if (oldestKey) {\n        this.responseCache.delete(oldestKey);\n      }\n    }\n  }\n}\nexport default new GeminiService();","map":{"version":3,"names":["GoogleGenerativeAI","GeminiService","constructor","genAI","model","responseCache","Map","CACHE_EXPIRY","apiKey","process","env","REACT_APP_GEMINI_API_KEY","getGenerativeModel","generationConfig","maxOutputTokens","temperature","topP","topK","console","warn","getPurchaseRecommendation","request","userCards","log","cacheKey","createCacheKey","cachedResponse","getCachedResponse","prompt","buildOptimizedConsultationPrompt","startTime","Date","now","result","generateContent","response","text","duration","parsedResponse","parseAIResponse","cacheResponse","getMockPurchaseRecommendation","error","cardsSummary","map","card","name","currentBalance","creditLimit","toFixed","rewards","rate","type","interestRate","join","purchaseAmount","purchaseCategory","description","preferredCard","buildConsultationPrompt","cardsInfo","issuer","toLocaleString","availableCredit","minimumPayment","dueDate","lastPaymentDate","lastPaymentAmount","responseText","_parsed$recommendatio","_parsed$recommendatio2","_parsed$recommendatio3","_parsed$recommendatio4","_parsed$alternatives","jsonMatch","match","Error","parsed","JSON","parse","recommendation","recommendedCard","reasoning","creditImpact","impactExplanation","alternatives","alt","cardId","cardName","pros","cons","tips","_userCards$","getGeneralCreditAdvice","question","toLowerCase","replace","getMockGeneralAdvice","bestCard","reduce","best","bestUtilization","currentUtilization","utilizationAfterPurchase","filter","id","Boolean","totalUtilization","sum","length","avgUtilization","includes","utilizationNum","parseFloat","cardsKey","key","cached","get","timestamp","data","delete","set","size","oldestKey","keys","next","value"],"sources":["/Users/hanngn/Documents/CreditScorecerer/credit-scorecerer/Web/src/services/GeminiService.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { CreditCard, AIConsultationRequest, AIConsultationResponse } from '../types';\n\nclass GeminiService {\n  private genAI: GoogleGenerativeAI | null = null;\n  private model: any = null;\n  private responseCache: Map<string, any> = new Map();\n  private readonly CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutes\n\n  constructor() {\n    const apiKey = process.env.REACT_APP_GEMINI_API_KEY;\n    if (apiKey && apiKey !== 'your_gemini_api_key_here') {\n      this.genAI = new GoogleGenerativeAI(apiKey);\n      // Pre-initialize the model for better performance\n      this.model = this.genAI.getGenerativeModel({ \n        model: 'gemini-2.5-flash',\n        generationConfig: {\n          maxOutputTokens: 1000, // Limit response length for faster responses\n          temperature: 0.3, // Lower temperature for more consistent, faster responses\n          topP: 0.8,\n          topK: 40\n        }\n      });\n    } else {\n      console.warn('Gemini API key not set or is placeholder. Using mock responses.');\n    }\n  }\n\n  async getPurchaseRecommendation(\n    request: AIConsultationRequest,\n    userCards: CreditCard[]\n  ): Promise<AIConsultationResponse> {\n    try {\n      console.log('GeminiService: Starting purchase consultation...');\n      \n      // Create cache key for similar requests\n      const cacheKey = this.createCacheKey(request, userCards);\n      const cachedResponse = this.getCachedResponse(cacheKey);\n      if (cachedResponse) {\n        console.log('Returning cached response');\n        return cachedResponse;\n      }\n      \n      if (this.model) {\n        console.log('Using Gemini API...');\n        \n        // Use optimized prompt\n        const prompt = this.buildOptimizedConsultationPrompt(request, userCards);\n        console.log('Sending optimized prompt to Gemini...');\n        \n        const startTime = Date.now();\n        const result = await this.model.generateContent(prompt);\n        const response = await result.response;\n        const text = response.text();\n        const duration = Date.now() - startTime;\n        console.log(`Gemini response received in ${duration}ms`);\n\n        const parsedResponse = this.parseAIResponse(text, userCards);\n        \n        // Cache the response\n        this.cacheResponse(cacheKey, parsedResponse);\n        \n        return parsedResponse;\n      } else {\n        console.log('Using mock response...');\n        return this.getMockPurchaseRecommendation(request, userCards);\n      }\n    } catch (error) {\n      console.error('Error getting AI recommendation:', error);\n      // Fallback to mock response on error\n      console.log('Falling back to mock response...');\n      return this.getMockPurchaseRecommendation(request, userCards);\n    }\n  }\n\n  private buildOptimizedConsultationPrompt(request: AIConsultationRequest, userCards: CreditCard[]): string {\n    // Optimized prompt - shorter and more focused\n    const cardsSummary = userCards.map(card => \n      `${card.name}: $${card.currentBalance}/${card.creditLimit} (${((card.currentBalance / card.creditLimit) * 100).toFixed(1)}%), ${card.rewards.rate}% ${card.rewards.type}, ${card.interestRate}% APR`\n    ).join(' | ');\n\n    return `Credit advisor: User has cards: ${cardsSummary}. \nPurchase: $${request.purchaseAmount} ${request.purchaseCategory} - ${request.description}\n${request.preferredCard ? `Preferred: ${request.preferredCard}` : ''}\n\nRespond with JSON only:\n{\n  \"recommendation\": {\n    \"recommendedCard\": \"card name\",\n    \"reasoning\": \"Brief reasoning with numbers\",\n    \"creditImpact\": \"positive|neutral|negative\", \n    \"impactExplanation\": \"brief impact\"\n  },\n  \"alternatives\": [{\"cardId\": \"id\", \"cardName\": \"name\", \"pros\": [\"pro\"], \"cons\": [\"con\"]}],\n  \"tips\": [\"tip1\", \"tip2\"]\n}`;\n  }\n\n  private buildConsultationPrompt(request: AIConsultationRequest, userCards: CreditCard[]): string {\n    const cardsInfo = userCards.map(card => \n      `Card: ${card.name} (${card.issuer})\n- Credit Limit: $${card.creditLimit.toLocaleString()}\n- Current Balance: $${card.currentBalance.toLocaleString()}\n- Available Credit: $${card.availableCredit.toLocaleString()}\n- Interest Rate: ${card.interestRate}%\n- Minimum Payment: $${card.minimumPayment}\n- Rewards: ${card.rewards.type} at ${card.rewards.rate}% rate\n- Utilization: ${((card.currentBalance / card.creditLimit) * 100).toFixed(1)}%\n- Due Date: ${card.dueDate}\n- Last Payment: ${card.lastPaymentDate || 'No recent payments'}\n- Last Payment Amount: ${card.lastPaymentAmount ? `$${card.lastPaymentAmount}` : 'N/A'}`\n    ).join('\\n\\n');\n\n    return `You are a direct, no-nonsense financial advisor helping with credit card purchase decisions. \n\nUser's Credit Cards with complete details:\n${cardsInfo}\n\nPurchase Details:\n- Amount: $${request.purchaseAmount}\n- Category: ${request.purchaseCategory}\n- Description: ${request.description}\n${request.preferredCard ? `- Preferred Card: ${request.preferredCard}` : ''}\n\nProvide a recommendation in the following JSON format with concrete, actionable guidance:\n{\n  \"recommendation\": {\n    \"recommendedCard\": \"Card name\",\n    \"reasoning\": \"Single paragraph with specific numbers, exact payment amounts, reward calculations, interest savings, credit score impact numbers, and concrete timeline recommendations. Be direct and practical.\",\n    \"creditImpact\": \"positive|neutral|negative\",\n    \"impactExplanation\": \"Specific percentage impact on credit score with exact numbers and timeline\"\n  },\n  \"alternatives\": [\n    {\n      \"cardId\": \"card-id\",\n      \"cardName\": \"Card name\",\n      \"pros\": [\"specific advantage with numbers\"],\n      \"cons\": [\"specific disadvantage with numbers\"]\n    }\n  ],\n  \"tips\": [\n    \"Concrete tip with specific numbers and actionable steps\",\n    \"Another concrete tip with exact amounts and timeline\"\n  ]\n}\n\nFocus on:\n- Specific utilization targets with exact percentages\n- Exact payment amounts and interest savings calculations\n- Reward optimization strategies with specific dollar amounts\n- Credit score impact numbers with concrete timeline\n- Payment due dates and cash flow optimization\n- Concrete timeline recommendations\n\nProvide practical, actionable advice with specific numbers and calculations.`;\n  }\n\n  private parseAIResponse(responseText: string, userCards: CreditCard[]): AIConsultationResponse {\n    try {\n      // Extract JSON from the response\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('No JSON found in response');\n      }\n\n      const parsed = JSON.parse(jsonMatch[0]);\n      \n      // Validate and map the response\n      return {\n        recommendation: {\n          recommendedCard: parsed.recommendation?.recommendedCard || 'Unknown',\n          reasoning: parsed.recommendation?.reasoning || 'No reasoning provided',\n          creditImpact: parsed.recommendation?.creditImpact || 'neutral',\n          impactExplanation: parsed.recommendation?.impactExplanation || 'No impact explanation'\n        },\n        alternatives: parsed.alternatives?.map((alt: any) => ({\n          cardId: alt.cardId || '',\n          cardName: alt.cardName || 'Unknown Card',\n          pros: alt.pros || [],\n          cons: alt.cons || []\n        })) || [],\n        tips: parsed.tips || []\n      };\n    } catch (error) {\n      console.error('Error parsing AI response:', error);\n      // Return a fallback response\n      return {\n        recommendation: {\n          recommendedCard: userCards[0]?.name || 'Unknown',\n          reasoning: 'Unable to parse AI response. Please try again.',\n          creditImpact: 'neutral',\n          impactExplanation: 'Unable to determine impact.'\n        },\n        alternatives: [],\n        tips: ['Consider your credit utilization when making purchases.', 'Pay off balances in full when possible.']\n      };\n    }\n  }\n\n  async getGeneralCreditAdvice(question: string, userCards: CreditCard[]): Promise<string> {\n    try {\n      console.log('GeminiService: Starting API call...');\n      \n      // Create cache key for similar questions\n      const cacheKey = `advice_${question.toLowerCase().replace(/[^a-z0-9]/g, '')}`;\n      const cachedResponse = this.getCachedResponse(cacheKey);\n      if (cachedResponse) {\n        console.log('Returning cached advice response');\n        return cachedResponse;\n      }\n      \n      if (this.model) {\n        console.log('Using Gemini API...');\n\n        // Optimized prompt - shorter and more direct\n        const cardsSummary = userCards.map(card => \n          `${card.name}: ${((card.currentBalance / card.creditLimit) * 100).toFixed(1)}% util`\n        ).join(', ');\n\n        const prompt = `Financial advisor. Cards: ${cardsSummary}. Question: ${question}. Give concise, actionable advice in 1-2 sentences.`;\n\n        console.log('Sending optimized prompt to Gemini...');\n        const startTime = Date.now();\n        const result = await this.model.generateContent(prompt);\n        const response = await result.response;\n        const text = response.text();\n        const duration = Date.now() - startTime;\n        console.log(`Gemini advice received in ${duration}ms`);\n        \n        // Cache the response\n        this.cacheResponse(cacheKey, text);\n        \n        return text;\n      } else {\n        console.log('Using mock response...');\n        return this.getMockGeneralAdvice(question, userCards);\n      }\n    } catch (error) {\n      console.error('Error getting general advice:', error);\n      // Fallback to mock response\n      console.log('Falling back to mock response...');\n      return this.getMockGeneralAdvice(question, userCards);\n    }\n  }\n\n  private getMockPurchaseRecommendation(\n    request: AIConsultationRequest,\n    userCards: CreditCard[]\n  ): AIConsultationResponse {\n    // Find the best card for the purchase based on rewards and utilization\n    const bestCard = userCards.reduce((best, card) => {\n      const bestUtilization = best.currentBalance / best.creditLimit;\n      const currentUtilization = card.currentBalance / card.creditLimit;\n      \n      // Prefer cards with lower utilization and higher rewards\n      if (currentUtilization < bestUtilization || \n          (currentUtilization === bestUtilization && card.rewards.rate > best.rewards.rate)) {\n        return card;\n      }\n      return best;\n    });\n\n    const utilizationAfterPurchase = (bestCard.currentBalance + request.purchaseAmount) / bestCard.creditLimit;\n    const creditImpact = utilizationAfterPurchase > 0.3 ? 'negative' : utilizationAfterPurchase > 0.1 ? 'neutral' : 'positive';\n\n    return {\n      recommendation: {\n        recommendedCard: bestCard.name,\n        reasoning: `Based on your current credit utilization and rewards structure, I recommend using your ${bestCard.name} for this $${request.purchaseAmount} ${request.purchaseCategory} purchase. This card offers ${bestCard.rewards.rate}% ${bestCard.rewards.type} rewards, and your utilization will remain at ${(utilizationAfterPurchase * 100).toFixed(1)}% after this purchase. Pay off the balance within the grace period to avoid interest charges of $${(request.purchaseAmount * bestCard.interestRate / 100 / 12).toFixed(2)} per month.`,\n        creditImpact,\n        impactExplanation: creditImpact === 'positive' \n          ? 'This purchase will help maintain low utilization, potentially improving your credit score'\n          : creditImpact === 'negative'\n          ? 'This purchase will increase your utilization above 30%, which may negatively impact your credit score'\n          : 'This purchase will have minimal impact on your credit score'\n      },\n      alternatives: userCards.filter(card => card.id !== bestCard.id).map(card => ({\n        cardId: card.id,\n        cardName: card.name,\n        pros: [\n          `${card.rewards.rate}% ${card.rewards.type} rewards`,\n          `Current utilization: ${((card.currentBalance / card.creditLimit) * 100).toFixed(1)}%`\n        ],\n        cons: [\n          card.interestRate > bestCard.interestRate ? `Higher interest rate (${card.interestRate}%)` : '',\n          card.currentBalance > bestCard.currentBalance ? 'Higher current balance' : ''\n        ].filter(Boolean)\n      })),\n      tips: [\n        `Pay off this purchase by ${bestCard.dueDate} to avoid interest charges`,\n        `Consider setting up automatic payments to avoid late fees`,\n        `Monitor your credit utilization to keep it below 30% for optimal credit score impact`\n      ]\n    };\n  }\n\n  private getMockGeneralAdvice(question: string, userCards: CreditCard[]): string {\n    const totalUtilization = userCards.reduce((sum, card) => {\n      return sum + (card.currentBalance / card.creditLimit);\n    }, 0) / userCards.length;\n\n    const avgUtilization = (totalUtilization * 100).toFixed(1);\n\n    if (question.toLowerCase().includes('utilization') || question.toLowerCase().includes('credit score')) {\n      return `Your current average credit utilization is ${avgUtilization}%. To improve your credit score, aim to keep utilization below 30%. Consider paying down your highest balance cards first, and avoid making large purchases that would push your utilization above this threshold. Your credit score can improve significantly by maintaining low utilization over time.`;\n    }\n\n    if (question.toLowerCase().includes('payment') || question.toLowerCase().includes('pay off')) {\n      return `Focus on paying off your highest interest rate cards first to minimize interest charges. Set up automatic payments for at least the minimum amount to avoid late fees, which can hurt your credit score. If possible, pay more than the minimum to reduce your principal balance faster.`;\n    }\n\n    if (question.toLowerCase().includes('reward') || question.toLowerCase().includes('cashback')) {\n      return `Your cards offer different reward structures. Use your highest reward rate card for purchases in categories where it offers the most value. Remember that rewards are only beneficial if you pay off your balance in full each month to avoid interest charges that could exceed the reward value.`;\n    }\n\n    // Default advice\n    const utilizationNum = parseFloat(avgUtilization);\n    return `Based on your current credit card situation, I recommend focusing on maintaining low credit utilization (below 30%), paying off high-interest balances first, and making payments on time. Your average utilization of ${avgUtilization}% ${utilizationNum > 30 ? 'could be improved' : 'is in a good range'}. Consider setting up automatic payments and monitoring your credit score regularly for optimal financial health.`;\n  }\n\n  // Caching utilities\n  private createCacheKey(request: AIConsultationRequest, userCards: CreditCard[]): string {\n    const cardsKey = userCards.map(card => `${card.id}_${card.currentBalance}_${card.creditLimit}`).join('|');\n    return `purchase_${request.purchaseAmount}_${request.purchaseCategory}_${cardsKey}`;\n  }\n\n  private getCachedResponse(key: string): any {\n    const cached = this.responseCache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.CACHE_EXPIRY) {\n      return cached.data;\n    }\n    // Remove expired cache\n    if (cached) {\n      this.responseCache.delete(key);\n    }\n    return null;\n  }\n\n  private cacheResponse(key: string, data: any): void {\n    this.responseCache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n    \n    // Clean up old cache entries if map gets too large\n    if (this.responseCache.size > 50) {\n      const oldestKey = this.responseCache.keys().next().value;\n      if (oldestKey) {\n        this.responseCache.delete(oldestKey);\n      }\n    }\n  }\n}\n\nexport default new GeminiService();\n"],"mappings":"AAAA,SAASA,kBAAkB,QAAQ,uBAAuB;AAG1D,MAAMC,aAAa,CAAC;EAI6B;;EAE/CC,WAAWA,CAAA,EAAG;IAAA,KALNC,KAAK,GAA8B,IAAI;IAAA,KACvCC,KAAK,GAAQ,IAAI;IAAA,KACjBC,aAAa,GAAqB,IAAIC,GAAG,CAAC,CAAC;IAAA,KAClCC,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI;IAG3C,MAAMC,MAAM,GAAGC,OAAO,CAACC,GAAG,CAACC,wBAAwB;IACnD,IAAIH,MAAM,IAAIA,MAAM,KAAK,0BAA0B,EAAE;MACnD,IAAI,CAACL,KAAK,GAAG,IAAIH,kBAAkB,CAACQ,MAAM,CAAC;MAC3C;MACA,IAAI,CAACJ,KAAK,GAAG,IAAI,CAACD,KAAK,CAACS,kBAAkB,CAAC;QACzCR,KAAK,EAAE,kBAAkB;QACzBS,gBAAgB,EAAE;UAChBC,eAAe,EAAE,IAAI;UAAE;UACvBC,WAAW,EAAE,GAAG;UAAE;UAClBC,IAAI,EAAE,GAAG;UACTC,IAAI,EAAE;QACR;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACLC,OAAO,CAACC,IAAI,CAAC,iEAAiE,CAAC;IACjF;EACF;EAEA,MAAMC,yBAAyBA,CAC7BC,OAA8B,EAC9BC,SAAuB,EACU;IACjC,IAAI;MACFJ,OAAO,CAACK,GAAG,CAAC,kDAAkD,CAAC;;MAE/D;MACA,MAAMC,QAAQ,GAAG,IAAI,CAACC,cAAc,CAACJ,OAAO,EAAEC,SAAS,CAAC;MACxD,MAAMI,cAAc,GAAG,IAAI,CAACC,iBAAiB,CAACH,QAAQ,CAAC;MACvD,IAAIE,cAAc,EAAE;QAClBR,OAAO,CAACK,GAAG,CAAC,2BAA2B,CAAC;QACxC,OAAOG,cAAc;MACvB;MAEA,IAAI,IAAI,CAACtB,KAAK,EAAE;QACdc,OAAO,CAACK,GAAG,CAAC,qBAAqB,CAAC;;QAElC;QACA,MAAMK,MAAM,GAAG,IAAI,CAACC,gCAAgC,CAACR,OAAO,EAAEC,SAAS,CAAC;QACxEJ,OAAO,CAACK,GAAG,CAAC,uCAAuC,CAAC;QAEpD,MAAMO,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;QAC5B,MAAMC,MAAM,GAAG,MAAM,IAAI,CAAC7B,KAAK,CAAC8B,eAAe,CAACN,MAAM,CAAC;QACvD,MAAMO,QAAQ,GAAG,MAAMF,MAAM,CAACE,QAAQ;QACtC,MAAMC,IAAI,GAAGD,QAAQ,CAACC,IAAI,CAAC,CAAC;QAC5B,MAAMC,QAAQ,GAAGN,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS;QACvCZ,OAAO,CAACK,GAAG,CAAC,+BAA+Bc,QAAQ,IAAI,CAAC;QAExD,MAAMC,cAAc,GAAG,IAAI,CAACC,eAAe,CAACH,IAAI,EAAEd,SAAS,CAAC;;QAE5D;QACA,IAAI,CAACkB,aAAa,CAAChB,QAAQ,EAAEc,cAAc,CAAC;QAE5C,OAAOA,cAAc;MACvB,CAAC,MAAM;QACLpB,OAAO,CAACK,GAAG,CAAC,wBAAwB,CAAC;QACrC,OAAO,IAAI,CAACkB,6BAA6B,CAACpB,OAAO,EAAEC,SAAS,CAAC;MAC/D;IACF,CAAC,CAAC,OAAOoB,KAAK,EAAE;MACdxB,OAAO,CAACwB,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MACxD;MACAxB,OAAO,CAACK,GAAG,CAAC,kCAAkC,CAAC;MAC/C,OAAO,IAAI,CAACkB,6BAA6B,CAACpB,OAAO,EAAEC,SAAS,CAAC;IAC/D;EACF;EAEQO,gCAAgCA,CAACR,OAA8B,EAAEC,SAAuB,EAAU;IACxG;IACA,MAAMqB,YAAY,GAAGrB,SAAS,CAACsB,GAAG,CAACC,IAAI,IACrC,GAAGA,IAAI,CAACC,IAAI,MAAMD,IAAI,CAACE,cAAc,IAAIF,IAAI,CAACG,WAAW,KAAK,CAAEH,IAAI,CAACE,cAAc,GAAGF,IAAI,CAACG,WAAW,GAAI,GAAG,EAAEC,OAAO,CAAC,CAAC,CAAC,OAAOJ,IAAI,CAACK,OAAO,CAACC,IAAI,KAAKN,IAAI,CAACK,OAAO,CAACE,IAAI,KAAKP,IAAI,CAACQ,YAAY,OAC/L,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC;IAEb,OAAO,mCAAmCX,YAAY;AAC1D,aAAatB,OAAO,CAACkC,cAAc,IAAIlC,OAAO,CAACmC,gBAAgB,MAAMnC,OAAO,CAACoC,WAAW;AACxF,EAAEpC,OAAO,CAACqC,aAAa,GAAG,cAAcrC,OAAO,CAACqC,aAAa,EAAE,GAAG,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;EACA;EAEQC,uBAAuBA,CAACtC,OAA8B,EAAEC,SAAuB,EAAU;IAC/F,MAAMsC,SAAS,GAAGtC,SAAS,CAACsB,GAAG,CAACC,IAAI,IAClC,SAASA,IAAI,CAACC,IAAI,KAAKD,IAAI,CAACgB,MAAM;AACxC,mBAAmBhB,IAAI,CAACG,WAAW,CAACc,cAAc,CAAC,CAAC;AACpD,sBAAsBjB,IAAI,CAACE,cAAc,CAACe,cAAc,CAAC,CAAC;AAC1D,uBAAuBjB,IAAI,CAACkB,eAAe,CAACD,cAAc,CAAC,CAAC;AAC5D,mBAAmBjB,IAAI,CAACQ,YAAY;AACpC,sBAAsBR,IAAI,CAACmB,cAAc;AACzC,aAAanB,IAAI,CAACK,OAAO,CAACE,IAAI,OAAOP,IAAI,CAACK,OAAO,CAACC,IAAI;AACtD,iBAAiB,CAAEN,IAAI,CAACE,cAAc,GAAGF,IAAI,CAACG,WAAW,GAAI,GAAG,EAAEC,OAAO,CAAC,CAAC,CAAC;AAC5E,cAAcJ,IAAI,CAACoB,OAAO;AAC1B,kBAAkBpB,IAAI,CAACqB,eAAe,IAAI,oBAAoB;AAC9D,yBAAyBrB,IAAI,CAACsB,iBAAiB,GAAG,IAAItB,IAAI,CAACsB,iBAAiB,EAAE,GAAG,KAAK,EAClF,CAAC,CAACb,IAAI,CAAC,MAAM,CAAC;IAEd,OAAO;AACX;AACA;AACA,EAAEM,SAAS;AACX;AACA;AACA,aAAavC,OAAO,CAACkC,cAAc;AACnC,cAAclC,OAAO,CAACmC,gBAAgB;AACtC,iBAAiBnC,OAAO,CAACoC,WAAW;AACpC,EAAEpC,OAAO,CAACqC,aAAa,GAAG,qBAAqBrC,OAAO,CAACqC,aAAa,EAAE,GAAG,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;EAC3E;EAEQnB,eAAeA,CAAC6B,YAAoB,EAAE9C,SAAuB,EAA0B;IAC7F,IAAI;MAAA,IAAA+C,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,oBAAA;MACF;MACA,MAAMC,SAAS,GAAGN,YAAY,CAACO,KAAK,CAAC,aAAa,CAAC;MACnD,IAAI,CAACD,SAAS,EAAE;QACd,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;MAC9C;MAEA,MAAMC,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACL,SAAS,CAAC,CAAC,CAAC,CAAC;;MAEvC;MACA,OAAO;QACLM,cAAc,EAAE;UACdC,eAAe,EAAE,EAAAZ,qBAAA,GAAAQ,MAAM,CAACG,cAAc,cAAAX,qBAAA,uBAArBA,qBAAA,CAAuBY,eAAe,KAAI,SAAS;UACpEC,SAAS,EAAE,EAAAZ,sBAAA,GAAAO,MAAM,CAACG,cAAc,cAAAV,sBAAA,uBAArBA,sBAAA,CAAuBY,SAAS,KAAI,uBAAuB;UACtEC,YAAY,EAAE,EAAAZ,sBAAA,GAAAM,MAAM,CAACG,cAAc,cAAAT,sBAAA,uBAArBA,sBAAA,CAAuBY,YAAY,KAAI,SAAS;UAC9DC,iBAAiB,EAAE,EAAAZ,sBAAA,GAAAK,MAAM,CAACG,cAAc,cAAAR,sBAAA,uBAArBA,sBAAA,CAAuBY,iBAAiB,KAAI;QACjE,CAAC;QACDC,YAAY,EAAE,EAAAZ,oBAAA,GAAAI,MAAM,CAACQ,YAAY,cAAAZ,oBAAA,uBAAnBA,oBAAA,CAAqB7B,GAAG,CAAE0C,GAAQ,KAAM;UACpDC,MAAM,EAAED,GAAG,CAACC,MAAM,IAAI,EAAE;UACxBC,QAAQ,EAAEF,GAAG,CAACE,QAAQ,IAAI,cAAc;UACxCC,IAAI,EAAEH,GAAG,CAACG,IAAI,IAAI,EAAE;UACpBC,IAAI,EAAEJ,GAAG,CAACI,IAAI,IAAI;QACpB,CAAC,CAAC,CAAC,KAAI,EAAE;QACTC,IAAI,EAAEd,MAAM,CAACc,IAAI,IAAI;MACvB,CAAC;IACH,CAAC,CAAC,OAAOjD,KAAK,EAAE;MAAA,IAAAkD,WAAA;MACd1E,OAAO,CAACwB,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClD;MACA,OAAO;QACLsC,cAAc,EAAE;UACdC,eAAe,EAAE,EAAAW,WAAA,GAAAtE,SAAS,CAAC,CAAC,CAAC,cAAAsE,WAAA,uBAAZA,WAAA,CAAc9C,IAAI,KAAI,SAAS;UAChDoC,SAAS,EAAE,gDAAgD;UAC3DC,YAAY,EAAE,SAAS;UACvBC,iBAAiB,EAAE;QACrB,CAAC;QACDC,YAAY,EAAE,EAAE;QAChBM,IAAI,EAAE,CAAC,yDAAyD,EAAE,yCAAyC;MAC7G,CAAC;IACH;EACF;EAEA,MAAME,sBAAsBA,CAACC,QAAgB,EAAExE,SAAuB,EAAmB;IACvF,IAAI;MACFJ,OAAO,CAACK,GAAG,CAAC,qCAAqC,CAAC;;MAElD;MACA,MAAMC,QAAQ,GAAG,UAAUsE,QAAQ,CAACC,WAAW,CAAC,CAAC,CAACC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,EAAE;MAC7E,MAAMtE,cAAc,GAAG,IAAI,CAACC,iBAAiB,CAACH,QAAQ,CAAC;MACvD,IAAIE,cAAc,EAAE;QAClBR,OAAO,CAACK,GAAG,CAAC,kCAAkC,CAAC;QAC/C,OAAOG,cAAc;MACvB;MAEA,IAAI,IAAI,CAACtB,KAAK,EAAE;QACdc,OAAO,CAACK,GAAG,CAAC,qBAAqB,CAAC;;QAElC;QACA,MAAMoB,YAAY,GAAGrB,SAAS,CAACsB,GAAG,CAACC,IAAI,IACrC,GAAGA,IAAI,CAACC,IAAI,KAAK,CAAED,IAAI,CAACE,cAAc,GAAGF,IAAI,CAACG,WAAW,GAAI,GAAG,EAAEC,OAAO,CAAC,CAAC,CAAC,QAC9E,CAAC,CAACK,IAAI,CAAC,IAAI,CAAC;QAEZ,MAAM1B,MAAM,GAAG,6BAA6Be,YAAY,eAAemD,QAAQ,qDAAqD;QAEpI5E,OAAO,CAACK,GAAG,CAAC,uCAAuC,CAAC;QACpD,MAAMO,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;QAC5B,MAAMC,MAAM,GAAG,MAAM,IAAI,CAAC7B,KAAK,CAAC8B,eAAe,CAACN,MAAM,CAAC;QACvD,MAAMO,QAAQ,GAAG,MAAMF,MAAM,CAACE,QAAQ;QACtC,MAAMC,IAAI,GAAGD,QAAQ,CAACC,IAAI,CAAC,CAAC;QAC5B,MAAMC,QAAQ,GAAGN,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS;QACvCZ,OAAO,CAACK,GAAG,CAAC,6BAA6Bc,QAAQ,IAAI,CAAC;;QAEtD;QACA,IAAI,CAACG,aAAa,CAAChB,QAAQ,EAAEY,IAAI,CAAC;QAElC,OAAOA,IAAI;MACb,CAAC,MAAM;QACLlB,OAAO,CAACK,GAAG,CAAC,wBAAwB,CAAC;QACrC,OAAO,IAAI,CAAC0E,oBAAoB,CAACH,QAAQ,EAAExE,SAAS,CAAC;MACvD;IACF,CAAC,CAAC,OAAOoB,KAAK,EAAE;MACdxB,OAAO,CAACwB,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;MACrD;MACAxB,OAAO,CAACK,GAAG,CAAC,kCAAkC,CAAC;MAC/C,OAAO,IAAI,CAAC0E,oBAAoB,CAACH,QAAQ,EAAExE,SAAS,CAAC;IACvD;EACF;EAEQmB,6BAA6BA,CACnCpB,OAA8B,EAC9BC,SAAuB,EACC;IACxB;IACA,MAAM4E,QAAQ,GAAG5E,SAAS,CAAC6E,MAAM,CAAC,CAACC,IAAI,EAAEvD,IAAI,KAAK;MAChD,MAAMwD,eAAe,GAAGD,IAAI,CAACrD,cAAc,GAAGqD,IAAI,CAACpD,WAAW;MAC9D,MAAMsD,kBAAkB,GAAGzD,IAAI,CAACE,cAAc,GAAGF,IAAI,CAACG,WAAW;;MAEjE;MACA,IAAIsD,kBAAkB,GAAGD,eAAe,IACnCC,kBAAkB,KAAKD,eAAe,IAAIxD,IAAI,CAACK,OAAO,CAACC,IAAI,GAAGiD,IAAI,CAAClD,OAAO,CAACC,IAAK,EAAE;QACrF,OAAON,IAAI;MACb;MACA,OAAOuD,IAAI;IACb,CAAC,CAAC;IAEF,MAAMG,wBAAwB,GAAG,CAACL,QAAQ,CAACnD,cAAc,GAAG1B,OAAO,CAACkC,cAAc,IAAI2C,QAAQ,CAAClD,WAAW;IAC1G,MAAMmC,YAAY,GAAGoB,wBAAwB,GAAG,GAAG,GAAG,UAAU,GAAGA,wBAAwB,GAAG,GAAG,GAAG,SAAS,GAAG,UAAU;IAE1H,OAAO;MACLvB,cAAc,EAAE;QACdC,eAAe,EAAEiB,QAAQ,CAACpD,IAAI;QAC9BoC,SAAS,EAAE,0FAA0FgB,QAAQ,CAACpD,IAAI,cAAczB,OAAO,CAACkC,cAAc,IAAIlC,OAAO,CAACmC,gBAAgB,+BAA+B0C,QAAQ,CAAChD,OAAO,CAACC,IAAI,KAAK+C,QAAQ,CAAChD,OAAO,CAACE,IAAI,iDAAiD,CAACmD,wBAAwB,GAAG,GAAG,EAAEtD,OAAO,CAAC,CAAC,CAAC,oGAAoG,CAAC5B,OAAO,CAACkC,cAAc,GAAG2C,QAAQ,CAAC7C,YAAY,GAAG,GAAG,GAAG,EAAE,EAAEJ,OAAO,CAAC,CAAC,CAAC,aAAa;QACnhBkC,YAAY;QACZC,iBAAiB,EAAED,YAAY,KAAK,UAAU,GAC1C,2FAA2F,GAC3FA,YAAY,KAAK,UAAU,GAC3B,uGAAuG,GACvG;MACN,CAAC;MACDE,YAAY,EAAE/D,SAAS,CAACkF,MAAM,CAAC3D,IAAI,IAAIA,IAAI,CAAC4D,EAAE,KAAKP,QAAQ,CAACO,EAAE,CAAC,CAAC7D,GAAG,CAACC,IAAI,KAAK;QAC3E0C,MAAM,EAAE1C,IAAI,CAAC4D,EAAE;QACfjB,QAAQ,EAAE3C,IAAI,CAACC,IAAI;QACnB2C,IAAI,EAAE,CACJ,GAAG5C,IAAI,CAACK,OAAO,CAACC,IAAI,KAAKN,IAAI,CAACK,OAAO,CAACE,IAAI,UAAU,EACpD,wBAAwB,CAAEP,IAAI,CAACE,cAAc,GAAGF,IAAI,CAACG,WAAW,GAAI,GAAG,EAAEC,OAAO,CAAC,CAAC,CAAC,GAAG,CACvF;QACDyC,IAAI,EAAE,CACJ7C,IAAI,CAACQ,YAAY,GAAG6C,QAAQ,CAAC7C,YAAY,GAAG,yBAAyBR,IAAI,CAACQ,YAAY,IAAI,GAAG,EAAE,EAC/FR,IAAI,CAACE,cAAc,GAAGmD,QAAQ,CAACnD,cAAc,GAAG,wBAAwB,GAAG,EAAE,CAC9E,CAACyD,MAAM,CAACE,OAAO;MAClB,CAAC,CAAC,CAAC;MACHf,IAAI,EAAE,CACJ,4BAA4BO,QAAQ,CAACjC,OAAO,4BAA4B,EACxE,2DAA2D,EAC3D,sFAAsF;IAE1F,CAAC;EACH;EAEQgC,oBAAoBA,CAACH,QAAgB,EAAExE,SAAuB,EAAU;IAC9E,MAAMqF,gBAAgB,GAAGrF,SAAS,CAAC6E,MAAM,CAAC,CAACS,GAAG,EAAE/D,IAAI,KAAK;MACvD,OAAO+D,GAAG,GAAI/D,IAAI,CAACE,cAAc,GAAGF,IAAI,CAACG,WAAY;IACvD,CAAC,EAAE,CAAC,CAAC,GAAG1B,SAAS,CAACuF,MAAM;IAExB,MAAMC,cAAc,GAAG,CAACH,gBAAgB,GAAG,GAAG,EAAE1D,OAAO,CAAC,CAAC,CAAC;IAE1D,IAAI6C,QAAQ,CAACC,WAAW,CAAC,CAAC,CAACgB,QAAQ,CAAC,aAAa,CAAC,IAAIjB,QAAQ,CAACC,WAAW,CAAC,CAAC,CAACgB,QAAQ,CAAC,cAAc,CAAC,EAAE;MACrG,OAAO,8CAA8CD,cAAc,0SAA0S;IAC/W;IAEA,IAAIhB,QAAQ,CAACC,WAAW,CAAC,CAAC,CAACgB,QAAQ,CAAC,SAAS,CAAC,IAAIjB,QAAQ,CAACC,WAAW,CAAC,CAAC,CAACgB,QAAQ,CAAC,SAAS,CAAC,EAAE;MAC5F,OAAO,0RAA0R;IACnS;IAEA,IAAIjB,QAAQ,CAACC,WAAW,CAAC,CAAC,CAACgB,QAAQ,CAAC,QAAQ,CAAC,IAAIjB,QAAQ,CAACC,WAAW,CAAC,CAAC,CAACgB,QAAQ,CAAC,UAAU,CAAC,EAAE;MAC5F,OAAO,oSAAoS;IAC7S;;IAEA;IACA,MAAMC,cAAc,GAAGC,UAAU,CAACH,cAAc,CAAC;IACjD,OAAO,0NAA0NA,cAAc,KAAKE,cAAc,GAAG,EAAE,GAAG,mBAAmB,GAAG,oBAAoB,mHAAmH;EACza;;EAEA;EACQvF,cAAcA,CAACJ,OAA8B,EAAEC,SAAuB,EAAU;IACtF,MAAM4F,QAAQ,GAAG5F,SAAS,CAACsB,GAAG,CAACC,IAAI,IAAI,GAAGA,IAAI,CAAC4D,EAAE,IAAI5D,IAAI,CAACE,cAAc,IAAIF,IAAI,CAACG,WAAW,EAAE,CAAC,CAACM,IAAI,CAAC,GAAG,CAAC;IACzG,OAAO,YAAYjC,OAAO,CAACkC,cAAc,IAAIlC,OAAO,CAACmC,gBAAgB,IAAI0D,QAAQ,EAAE;EACrF;EAEQvF,iBAAiBA,CAACwF,GAAW,EAAO;IAC1C,MAAMC,MAAM,GAAG,IAAI,CAAC/G,aAAa,CAACgH,GAAG,CAACF,GAAG,CAAC;IAC1C,IAAIC,MAAM,IAAIrF,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGoF,MAAM,CAACE,SAAS,GAAG,IAAI,CAAC/G,YAAY,EAAE;MAC/D,OAAO6G,MAAM,CAACG,IAAI;IACpB;IACA;IACA,IAAIH,MAAM,EAAE;MACV,IAAI,CAAC/G,aAAa,CAACmH,MAAM,CAACL,GAAG,CAAC;IAChC;IACA,OAAO,IAAI;EACb;EAEQ3E,aAAaA,CAAC2E,GAAW,EAAEI,IAAS,EAAQ;IAClD,IAAI,CAAClH,aAAa,CAACoH,GAAG,CAACN,GAAG,EAAE;MAC1BI,IAAI;MACJD,SAAS,EAAEvF,IAAI,CAACC,GAAG,CAAC;IACtB,CAAC,CAAC;;IAEF;IACA,IAAI,IAAI,CAAC3B,aAAa,CAACqH,IAAI,GAAG,EAAE,EAAE;MAChC,MAAMC,SAAS,GAAG,IAAI,CAACtH,aAAa,CAACuH,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,KAAK;MACxD,IAAIH,SAAS,EAAE;QACb,IAAI,CAACtH,aAAa,CAACmH,MAAM,CAACG,SAAS,CAAC;MACtC;IACF;EACF;AACF;AAEA,eAAe,IAAI1H,aAAa,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}