{"ast":null,"code":"class AuthService {\n  constructor() {\n    this.STORAGE_KEY = 'credit_scorecerer_auth';\n    // Mock user database (in real app, this would be a backend API)\n    this.mockUsers = [{\n      id: '1',\n      email: 'demo@example.com',\n      name: 'Demo User',\n      createdAt: '2024-01-01T00:00:00Z'\n    }];\n  }\n  async signUp(request) {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Check if user already exists\n    const existingUser = this.mockUsers.find(user => user.email === request.email);\n    if (existingUser) {\n      throw new Error('User with this email already exists');\n    }\n\n    // Validate input\n    if (!request.name || !request.email || !request.password) {\n      throw new Error('All fields are required');\n    }\n    if (request.password.length < 6) {\n      throw new Error('Password must be at least 6 characters');\n    }\n    if (!this.isValidEmail(request.email)) {\n      throw new Error('Please enter a valid email address');\n    }\n\n    // Create new user\n    const newUser = {\n      id: (this.mockUsers.length + 1).toString(),\n      email: request.email,\n      name: request.name,\n      createdAt: new Date().toISOString()\n    };\n\n    // Add to mock database\n    this.mockUsers.push(newUser);\n\n    // Generate mock token\n    const token = this.generateMockToken(newUser.id);\n    const response = {\n      user: newUser,\n      token\n    };\n\n    // Store in localStorage\n    this.storeAuth(response);\n    return response;\n  }\n  async login(request) {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Validate input\n    if (!request.email || !request.password) {\n      throw new Error('Email and password are required');\n    }\n\n    // For demo purposes, accept any password for demo@example.com\n    if (request.email === 'demo@example.com') {\n      const user = this.mockUsers.find(u => u.email === request.email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n      const token = this.generateMockToken(user.id);\n      const response = {\n        user,\n        token\n      };\n      this.storeAuth(response);\n      return response;\n    }\n\n    // Find user in mock database\n    const user = this.mockUsers.find(u => u.email === request.email);\n    if (!user) {\n      throw new Error('Invalid email or password');\n    }\n\n    // In a real app, you would verify the password hash here\n    // For demo purposes, we'll accept any password\n    const token = this.generateMockToken(user.id);\n    const response = {\n      user,\n      token\n    };\n    this.storeAuth(response);\n    return response;\n  }\n  async logout() {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Remove from localStorage\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n  async getCurrentUser() {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n    try {\n      const authData = JSON.parse(stored);\n\n      // Verify token (in real app, this would be done on the server)\n      if (!this.isValidToken(authData.token)) {\n        this.clearAuth();\n        return null;\n      }\n      return authData.user;\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      this.clearAuth();\n      return null;\n    }\n  }\n  async refreshToken() {\n    const currentUser = await this.getCurrentUser();\n    if (!currentUser) {\n      return null;\n    }\n    const newToken = this.generateMockToken(currentUser.id);\n\n    // Update stored token\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      try {\n        const authData = JSON.parse(stored);\n        authData.token = newToken;\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n      } catch (error) {\n        console.error('Error updating token:', error);\n      }\n    }\n    return newToken;\n  }\n  storeAuth(authData) {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n  }\n  clearAuth() {\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n  generateMockToken(userId) {\n    // In a real app, this would be generated by the server\n    const payload = {\n      userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + 24 * 60 * 60 // 24 hours\n    };\n    return btoa(JSON.stringify(payload));\n  }\n  isValidToken(token) {\n    try {\n      const payload = JSON.parse(atob(token));\n      const now = Math.floor(Date.now() / 1000);\n      return payload.exp > now;\n    } catch (error) {\n      return false;\n    }\n  }\n  isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Get auth data from localStorage (synchronous)\n  getStoredAuth() {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n    try {\n      return JSON.parse(stored);\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      return null;\n    }\n  }\n}\nexport default new AuthService();","map":{"version":3,"names":["AuthService","constructor","STORAGE_KEY","mockUsers","id","email","name","createdAt","signUp","request","Promise","resolve","setTimeout","existingUser","find","user","Error","password","length","isValidEmail","newUser","toString","Date","toISOString","push","token","generateMockToken","response","storeAuth","login","u","logout","localStorage","removeItem","getCurrentUser","stored","getItem","authData","JSON","parse","isValidToken","clearAuth","error","console","refreshToken","currentUser","newToken","setItem","stringify","userId","payload","iat","Math","floor","now","exp","btoa","atob","emailRegex","test","getStoredAuth"],"sources":["/Users/hanngn/Documents/CreditScorecerer/credit-scorecerer/Web/src/services/AuthService.ts"],"sourcesContent":["import { AuthUser, LoginRequest, SignUpRequest, AuthResponse } from '../types';\n\nclass AuthService {\n  private readonly STORAGE_KEY = 'credit_scorecerer_auth';\n\n  // Mock user database (in real app, this would be a backend API)\n  private mockUsers: AuthUser[] = [\n    {\n      id: '1',\n      email: 'demo@example.com',\n      name: 'Demo User',\n      createdAt: '2024-01-01T00:00:00Z'\n    }\n  ];\n\n  async signUp(request: SignUpRequest): Promise<AuthResponse> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Check if user already exists\n    const existingUser = this.mockUsers.find(user => user.email === request.email);\n    if (existingUser) {\n      throw new Error('User with this email already exists');\n    }\n\n    // Validate input\n    if (!request.name || !request.email || !request.password) {\n      throw new Error('All fields are required');\n    }\n\n    if (request.password.length < 6) {\n      throw new Error('Password must be at least 6 characters');\n    }\n\n    if (!this.isValidEmail(request.email)) {\n      throw new Error('Please enter a valid email address');\n    }\n\n    // Create new user\n    const newUser: AuthUser = {\n      id: (this.mockUsers.length + 1).toString(),\n      email: request.email,\n      name: request.name,\n      createdAt: new Date().toISOString()\n    };\n\n    // Add to mock database\n    this.mockUsers.push(newUser);\n\n    // Generate mock token\n    const token = this.generateMockToken(newUser.id);\n\n    const response: AuthResponse = {\n      user: newUser,\n      token\n    };\n\n    // Store in localStorage\n    this.storeAuth(response);\n\n    return response;\n  }\n\n  async login(request: LoginRequest): Promise<AuthResponse> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Validate input\n    if (!request.email || !request.password) {\n      throw new Error('Email and password are required');\n    }\n\n    // For demo purposes, accept any password for demo@example.com\n    if (request.email === 'demo@example.com') {\n      const user = this.mockUsers.find(u => u.email === request.email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      const token = this.generateMockToken(user.id);\n      const response: AuthResponse = {\n        user,\n        token\n      };\n\n      this.storeAuth(response);\n      return response;\n    }\n\n    // Find user in mock database\n    const user = this.mockUsers.find(u => u.email === request.email);\n    if (!user) {\n      throw new Error('Invalid email or password');\n    }\n\n    // In a real app, you would verify the password hash here\n    // For demo purposes, we'll accept any password\n    const token = this.generateMockToken(user.id);\n    const response: AuthResponse = {\n      user,\n      token\n    };\n\n    this.storeAuth(response);\n    return response;\n  }\n\n  async logout(): Promise<void> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Remove from localStorage\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n\n  async getCurrentUser(): Promise<AuthUser | null> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n\n    try {\n      const authData: AuthResponse = JSON.parse(stored);\n      \n      // Verify token (in real app, this would be done on the server)\n      if (!this.isValidToken(authData.token)) {\n        this.clearAuth();\n        return null;\n      }\n\n      return authData.user;\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      this.clearAuth();\n      return null;\n    }\n  }\n\n  async refreshToken(): Promise<string | null> {\n    const currentUser = await this.getCurrentUser();\n    if (!currentUser) {\n      return null;\n    }\n\n    const newToken = this.generateMockToken(currentUser.id);\n    \n    // Update stored token\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      try {\n        const authData: AuthResponse = JSON.parse(stored);\n        authData.token = newToken;\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n      } catch (error) {\n        console.error('Error updating token:', error);\n      }\n    }\n\n    return newToken;\n  }\n\n  private storeAuth(authData: AuthResponse): void {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n  }\n\n  private clearAuth(): void {\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n\n  private generateMockToken(userId: string): string {\n    // In a real app, this would be generated by the server\n    const payload = {\n      userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours\n    };\n    \n    return btoa(JSON.stringify(payload));\n  }\n\n  private isValidToken(token: string): boolean {\n    try {\n      const payload = JSON.parse(atob(token));\n      const now = Math.floor(Date.now() / 1000);\n      return payload.exp > now;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Get auth data from localStorage (synchronous)\n  getStoredAuth(): AuthResponse | null {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(stored);\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      return null;\n    }\n  }\n}\n\nexport default new AuthService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}