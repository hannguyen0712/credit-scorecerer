{"ast":null,"code":"class AuthService {\n  constructor() {\n    // Fallback mock user database\n    this.mockUsers = [{\n      id: '1',\n      email: 'demo@example.com',\n      name: 'Demo User',\n      createdAt: '2024-01-01T00:00:00Z'\n    }];\n  }\n  // Check if Supabase is configured\n  get isSupabaseConfigured() {\n    return !!(process.env.REACT_APP_SUPABASE_URL && process.env.REACT_APP_SUPABASE_ANON_KEY);\n  }\n  async signUp(request) {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Check if user already exists\n    const existingUser = this.mockUsers.find(user => user.email === request.email);\n    if (existingUser) {\n      throw new Error('User with this email already exists');\n    }\n\n    // Validate input\n    if (!request.name || !request.email || !request.password) {\n      throw new Error('All fields are required');\n    }\n    if (request.password.length < 6) {\n      throw new Error('Password must be at least 6 characters');\n    }\n    if (!this.isValidEmail(request.email)) {\n      throw new Error('Please enter a valid email address');\n    }\n\n    // Create new user\n    const newUser = {\n      id: (this.mockUsers.length + 1).toString(),\n      email: request.email,\n      name: request.name,\n      createdAt: new Date().toISOString()\n    };\n\n    // Add to mock database\n    this.mockUsers.push(newUser);\n\n    // Generate mock token\n    const token = this.generateMockToken(newUser.id);\n    const response = {\n      user: newUser,\n      token\n    };\n\n    // Store in localStorage\n    this.storeAuth(response);\n    return response;\n  }\n  async login(request) {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Validate input\n    if (!request.email || !request.password) {\n      throw new Error('Email and password are required');\n    }\n\n    // For demo purposes, accept any password for demo@example.com\n    if (request.email === 'demo@example.com') {\n      const user = this.mockUsers.find(u => u.email === request.email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n      const token = this.generateMockToken(user.id);\n      const response = {\n        user,\n        token\n      };\n      this.storeAuth(response);\n      return response;\n    }\n\n    // Find user in mock database\n    const user = this.mockUsers.find(u => u.email === request.email);\n    if (!user) {\n      throw new Error('Invalid email or password');\n    }\n\n    // In a real app, you would verify the password hash here\n    // For demo purposes, we'll accept any password\n    const token = this.generateMockToken(user.id);\n    const response = {\n      user,\n      token\n    };\n    this.storeAuth(response);\n    return response;\n  }\n  async logout() {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Remove from localStorage\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n  async getCurrentUser() {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n    try {\n      const authData = JSON.parse(stored);\n\n      // Verify token (in real app, this would be done on the server)\n      if (!this.isValidToken(authData.token)) {\n        this.clearAuth();\n        return null;\n      }\n      return authData.user;\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      this.clearAuth();\n      return null;\n    }\n  }\n  async refreshToken() {\n    const currentUser = await this.getCurrentUser();\n    if (!currentUser) {\n      return null;\n    }\n    const newToken = this.generateMockToken(currentUser.id);\n\n    // Update stored token\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      try {\n        const authData = JSON.parse(stored);\n        authData.token = newToken;\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n      } catch (error) {\n        console.error('Error updating token:', error);\n      }\n    }\n    return newToken;\n  }\n  storeAuth(authData) {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n  }\n  clearAuth() {\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n  generateMockToken(userId) {\n    // In a real app, this would be generated by the server\n    const payload = {\n      userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + 24 * 60 * 60 // 24 hours\n    };\n    return btoa(JSON.stringify(payload));\n  }\n  isValidToken(token) {\n    try {\n      const payload = JSON.parse(atob(token));\n      const now = Math.floor(Date.now() / 1000);\n      return payload.exp > now;\n    } catch (error) {\n      return false;\n    }\n  }\n  isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Get auth data from localStorage (synchronous)\n  getStoredAuth() {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n    try {\n      return JSON.parse(stored);\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      return null;\n    }\n  }\n}\nexport default new AuthService();","map":{"version":3,"names":["AuthService","constructor","mockUsers","id","email","name","createdAt","isSupabaseConfigured","process","env","REACT_APP_SUPABASE_URL","REACT_APP_SUPABASE_ANON_KEY","signUp","request","Promise","resolve","setTimeout","existingUser","find","user","Error","password","length","isValidEmail","newUser","toString","Date","toISOString","push","token","generateMockToken","response","storeAuth","login","u","logout","localStorage","removeItem","STORAGE_KEY","getCurrentUser","stored","getItem","authData","JSON","parse","isValidToken","clearAuth","error","console","refreshToken","currentUser","newToken","setItem","stringify","userId","payload","iat","Math","floor","now","exp","btoa","atob","emailRegex","test","getStoredAuth"],"sources":["/Users/hanngn/Documents/CreditScorecerer/credit-scorecerer/Web/src/services/AuthService.ts"],"sourcesContent":["import { AuthUser, LoginRequest, SignUpRequest, AuthResponse } from '../types';\nimport { supabase } from '../config/supabase';\n\nclass AuthService {\n  // Check if Supabase is configured\n  private get isSupabaseConfigured(): boolean {\n    return !!(process.env.REACT_APP_SUPABASE_URL && process.env.REACT_APP_SUPABASE_ANON_KEY);\n  }\n\n  // Fallback mock user database\n  private mockUsers: AuthUser[] = [\n    {\n      id: '1',\n      email: 'demo@example.com',\n      name: 'Demo User',\n      createdAt: '2024-01-01T00:00:00Z'\n    }\n  ];\n\n  async signUp(request: SignUpRequest): Promise<AuthResponse> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Check if user already exists\n    const existingUser = this.mockUsers.find(user => user.email === request.email);\n    if (existingUser) {\n      throw new Error('User with this email already exists');\n    }\n\n    // Validate input\n    if (!request.name || !request.email || !request.password) {\n      throw new Error('All fields are required');\n    }\n\n    if (request.password.length < 6) {\n      throw new Error('Password must be at least 6 characters');\n    }\n\n    if (!this.isValidEmail(request.email)) {\n      throw new Error('Please enter a valid email address');\n    }\n\n    // Create new user\n    const newUser: AuthUser = {\n      id: (this.mockUsers.length + 1).toString(),\n      email: request.email,\n      name: request.name,\n      createdAt: new Date().toISOString()\n    };\n\n    // Add to mock database\n    this.mockUsers.push(newUser);\n\n    // Generate mock token\n    const token = this.generateMockToken(newUser.id);\n\n    const response: AuthResponse = {\n      user: newUser,\n      token\n    };\n\n    // Store in localStorage\n    this.storeAuth(response);\n\n    return response;\n  }\n\n  async login(request: LoginRequest): Promise<AuthResponse> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Validate input\n    if (!request.email || !request.password) {\n      throw new Error('Email and password are required');\n    }\n\n    // For demo purposes, accept any password for demo@example.com\n    if (request.email === 'demo@example.com') {\n      const user = this.mockUsers.find(u => u.email === request.email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      const token = this.generateMockToken(user.id);\n      const response: AuthResponse = {\n        user,\n        token\n      };\n\n      this.storeAuth(response);\n      return response;\n    }\n\n    // Find user in mock database\n    const user = this.mockUsers.find(u => u.email === request.email);\n    if (!user) {\n      throw new Error('Invalid email or password');\n    }\n\n    // In a real app, you would verify the password hash here\n    // For demo purposes, we'll accept any password\n    const token = this.generateMockToken(user.id);\n    const response: AuthResponse = {\n      user,\n      token\n    };\n\n    this.storeAuth(response);\n    return response;\n  }\n\n  async logout(): Promise<void> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Remove from localStorage\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n\n  async getCurrentUser(): Promise<AuthUser | null> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n\n    try {\n      const authData: AuthResponse = JSON.parse(stored);\n      \n      // Verify token (in real app, this would be done on the server)\n      if (!this.isValidToken(authData.token)) {\n        this.clearAuth();\n        return null;\n      }\n\n      return authData.user;\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      this.clearAuth();\n      return null;\n    }\n  }\n\n  async refreshToken(): Promise<string | null> {\n    const currentUser = await this.getCurrentUser();\n    if (!currentUser) {\n      return null;\n    }\n\n    const newToken = this.generateMockToken(currentUser.id);\n    \n    // Update stored token\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      try {\n        const authData: AuthResponse = JSON.parse(stored);\n        authData.token = newToken;\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n      } catch (error) {\n        console.error('Error updating token:', error);\n      }\n    }\n\n    return newToken;\n  }\n\n  private storeAuth(authData: AuthResponse): void {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n  }\n\n  private clearAuth(): void {\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n\n  private generateMockToken(userId: string): string {\n    // In a real app, this would be generated by the server\n    const payload = {\n      userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours\n    };\n    \n    return btoa(JSON.stringify(payload));\n  }\n\n  private isValidToken(token: string): boolean {\n    try {\n      const payload = JSON.parse(atob(token));\n      const now = Math.floor(Date.now() / 1000);\n      return payload.exp > now;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Get auth data from localStorage (synchronous)\n  getStoredAuth(): AuthResponse | null {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(stored);\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      return null;\n    }\n  }\n}\n\nexport default new AuthService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}