{"ast":null,"code":"import { supabase } from '../config/supabase';\nclass AuthService {\n  constructor() {\n    // Fallback mock user database\n    this.mockUsers = [{\n      id: '1',\n      email: 'demo@example.com',\n      name: 'Demo User',\n      createdAt: '2024-01-01T00:00:00Z'\n    }];\n  }\n  // Check if Supabase is configured\n  get isSupabaseConfigured() {\n    return !!(process.env.REACT_APP_SUPABASE_URL && process.env.REACT_APP_SUPABASE_ANON_KEY);\n  }\n  async signUp(request) {\n    // Validate input\n    if (!request.name || !request.email || !request.password) {\n      throw new Error('All fields are required');\n    }\n    if (request.password.length < 6) {\n      throw new Error('Password must be at least 6 characters');\n    }\n    if (!this.isValidEmail(request.email)) {\n      throw new Error('Please enter a valid email address');\n    }\n    if (this.isSupabaseConfigured) {\n      try {\n        var _authData$session;\n        // Use Supabase Auth\n        const {\n          data: authData,\n          error: authError\n        } = await supabase.auth.signUp({\n          email: request.email,\n          password: request.password,\n          options: {\n            data: {\n              name: request.name\n            }\n          }\n        });\n        if (authError) {\n          throw new Error(authError.message);\n        }\n        if (!authData.user) {\n          throw new Error('Failed to create user account');\n        }\n\n        // Create user profile in our custom users table\n        const {\n          error: profileError\n        } = await supabase.from('users').insert({\n          id: authData.user.id,\n          email: request.email,\n          name: request.name\n        });\n        if (profileError) {\n          console.error('Error creating user profile:', profileError);\n          // Don't throw error here as the auth user was created successfully\n        }\n        const user = {\n          id: authData.user.id,\n          email: request.email,\n          name: request.name,\n          createdAt: authData.user.created_at\n        };\n        const response = {\n          user,\n          token: ((_authData$session = authData.session) === null || _authData$session === void 0 ? void 0 : _authData$session.access_token) || ''\n        };\n        return response;\n      } catch (error) {\n        console.error('Supabase signup error:', error);\n        throw error;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockSignUp(request);\n    }\n  }\n  async login(request) {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Validate input\n    if (!request.email || !request.password) {\n      throw new Error('Email and password are required');\n    }\n\n    // For demo purposes, accept any password for demo@example.com\n    if (request.email === 'demo@example.com') {\n      const user = this.mockUsers.find(u => u.email === request.email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n      const token = this.generateMockToken(user.id);\n      const response = {\n        user,\n        token\n      };\n      this.storeAuth(response);\n      return response;\n    }\n\n    // Find user in mock database\n    const user = this.mockUsers.find(u => u.email === request.email);\n    if (!user) {\n      throw new Error('Invalid email or password');\n    }\n\n    // In a real app, you would verify the password hash here\n    // For demo purposes, we'll accept any password\n    const token = this.generateMockToken(user.id);\n    const response = {\n      user,\n      token\n    };\n    this.storeAuth(response);\n    return response;\n  }\n  async logout() {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Remove from localStorage\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n  async getCurrentUser() {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n    try {\n      const authData = JSON.parse(stored);\n\n      // Verify token (in real app, this would be done on the server)\n      if (!this.isValidToken(authData.token)) {\n        this.clearAuth();\n        return null;\n      }\n      return authData.user;\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      this.clearAuth();\n      return null;\n    }\n  }\n  async refreshToken() {\n    const currentUser = await this.getCurrentUser();\n    if (!currentUser) {\n      return null;\n    }\n    const newToken = this.generateMockToken(currentUser.id);\n\n    // Update stored token\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      try {\n        const authData = JSON.parse(stored);\n        authData.token = newToken;\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n      } catch (error) {\n        console.error('Error updating token:', error);\n      }\n    }\n    return newToken;\n  }\n  storeAuth(authData) {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n  }\n  clearAuth() {\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n  generateMockToken(userId) {\n    // In a real app, this would be generated by the server\n    const payload = {\n      userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + 24 * 60 * 60 // 24 hours\n    };\n    return btoa(JSON.stringify(payload));\n  }\n  isValidToken(token) {\n    try {\n      const payload = JSON.parse(atob(token));\n      const now = Math.floor(Date.now() / 1000);\n      return payload.exp > now;\n    } catch (error) {\n      return false;\n    }\n  }\n  isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Get auth data from localStorage (synchronous)\n  getStoredAuth() {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n    try {\n      return JSON.parse(stored);\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      return null;\n    }\n  }\n}\nexport default new AuthService();","map":{"version":3,"names":["supabase","AuthService","constructor","mockUsers","id","email","name","createdAt","isSupabaseConfigured","process","env","REACT_APP_SUPABASE_URL","REACT_APP_SUPABASE_ANON_KEY","signUp","request","password","Error","length","isValidEmail","_authData$session","data","authData","error","authError","auth","options","message","user","profileError","from","insert","console","created_at","response","token","session","access_token","warn","mockSignUp","login","Promise","resolve","setTimeout","find","u","generateMockToken","storeAuth","logout","localStorage","removeItem","STORAGE_KEY","getCurrentUser","stored","getItem","JSON","parse","isValidToken","clearAuth","refreshToken","currentUser","newToken","setItem","stringify","userId","payload","iat","Math","floor","Date","now","exp","btoa","atob","emailRegex","test","getStoredAuth"],"sources":["/Users/hanngn/Documents/CreditScorecerer/credit-scorecerer/Web/src/services/AuthService.ts"],"sourcesContent":["import { AuthUser, LoginRequest, SignUpRequest, AuthResponse } from '../types';\nimport { supabase } from '../config/supabase';\n\nclass AuthService {\n  // Check if Supabase is configured\n  private get isSupabaseConfigured(): boolean {\n    return !!(process.env.REACT_APP_SUPABASE_URL && process.env.REACT_APP_SUPABASE_ANON_KEY);\n  }\n\n  // Fallback mock user database\n  private mockUsers: AuthUser[] = [\n    {\n      id: '1',\n      email: 'demo@example.com',\n      name: 'Demo User',\n      createdAt: '2024-01-01T00:00:00Z'\n    }\n  ];\n\n  async signUp(request: SignUpRequest): Promise<AuthResponse> {\n    // Validate input\n    if (!request.name || !request.email || !request.password) {\n      throw new Error('All fields are required');\n    }\n\n    if (request.password.length < 6) {\n      throw new Error('Password must be at least 6 characters');\n    }\n\n    if (!this.isValidEmail(request.email)) {\n      throw new Error('Please enter a valid email address');\n    }\n\n    if (this.isSupabaseConfigured) {\n      try {\n        // Use Supabase Auth\n        const { data: authData, error: authError } = await supabase.auth.signUp({\n          email: request.email,\n          password: request.password,\n          options: {\n            data: {\n              name: request.name\n            }\n          }\n        });\n\n        if (authError) {\n          throw new Error(authError.message);\n        }\n\n        if (!authData.user) {\n          throw new Error('Failed to create user account');\n        }\n\n        // Create user profile in our custom users table\n        const { error: profileError } = await supabase\n          .from('users')\n          .insert({\n            id: authData.user.id,\n            email: request.email,\n            name: request.name\n          });\n\n        if (profileError) {\n          console.error('Error creating user profile:', profileError);\n          // Don't throw error here as the auth user was created successfully\n        }\n\n        const user: AuthUser = {\n          id: authData.user.id,\n          email: request.email,\n          name: request.name,\n          createdAt: authData.user.created_at\n        };\n\n        const response: AuthResponse = {\n          user,\n          token: authData.session?.access_token || ''\n        };\n\n        return response;\n      } catch (error) {\n        console.error('Supabase signup error:', error);\n        throw error;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockSignUp(request);\n    }\n  }\n\n  async login(request: LoginRequest): Promise<AuthResponse> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Validate input\n    if (!request.email || !request.password) {\n      throw new Error('Email and password are required');\n    }\n\n    // For demo purposes, accept any password for demo@example.com\n    if (request.email === 'demo@example.com') {\n      const user = this.mockUsers.find(u => u.email === request.email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      const token = this.generateMockToken(user.id);\n      const response: AuthResponse = {\n        user,\n        token\n      };\n\n      this.storeAuth(response);\n      return response;\n    }\n\n    // Find user in mock database\n    const user = this.mockUsers.find(u => u.email === request.email);\n    if (!user) {\n      throw new Error('Invalid email or password');\n    }\n\n    // In a real app, you would verify the password hash here\n    // For demo purposes, we'll accept any password\n    const token = this.generateMockToken(user.id);\n    const response: AuthResponse = {\n      user,\n      token\n    };\n\n    this.storeAuth(response);\n    return response;\n  }\n\n  async logout(): Promise<void> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Remove from localStorage\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n\n  async getCurrentUser(): Promise<AuthUser | null> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n\n    try {\n      const authData: AuthResponse = JSON.parse(stored);\n      \n      // Verify token (in real app, this would be done on the server)\n      if (!this.isValidToken(authData.token)) {\n        this.clearAuth();\n        return null;\n      }\n\n      return authData.user;\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      this.clearAuth();\n      return null;\n    }\n  }\n\n  async refreshToken(): Promise<string | null> {\n    const currentUser = await this.getCurrentUser();\n    if (!currentUser) {\n      return null;\n    }\n\n    const newToken = this.generateMockToken(currentUser.id);\n    \n    // Update stored token\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      try {\n        const authData: AuthResponse = JSON.parse(stored);\n        authData.token = newToken;\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n      } catch (error) {\n        console.error('Error updating token:', error);\n      }\n    }\n\n    return newToken;\n  }\n\n  private storeAuth(authData: AuthResponse): void {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n  }\n\n  private clearAuth(): void {\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n\n  private generateMockToken(userId: string): string {\n    // In a real app, this would be generated by the server\n    const payload = {\n      userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours\n    };\n    \n    return btoa(JSON.stringify(payload));\n  }\n\n  private isValidToken(token: string): boolean {\n    try {\n      const payload = JSON.parse(atob(token));\n      const now = Math.floor(Date.now() / 1000);\n      return payload.exp > now;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Get auth data from localStorage (synchronous)\n  getStoredAuth(): AuthResponse | null {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(stored);\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      return null;\n    }\n  }\n}\n\nexport default new AuthService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}