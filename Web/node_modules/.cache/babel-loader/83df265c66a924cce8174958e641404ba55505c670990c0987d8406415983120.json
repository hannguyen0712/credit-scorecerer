{"ast":null,"code":"// import { supabase } from '../config/supabase';\n\nclass AuthService {\n  constructor() {\n    this.STORAGE_KEY = 'credit_scorecerer_auth';\n    // Fallback mock user database\n    this.mockUsers = [{\n      id: '1',\n      email: 'demo@example.com',\n      name: 'Demo User',\n      createdAt: '2024-01-01T00:00:00Z'\n    }];\n  }\n  // Check if Supabase is configured\n  get isSupabaseConfigured() {\n    return !!(process.env.REACT_APP_SUPABASE_URL && process.env.REACT_APP_SUPABASE_ANON_KEY);\n  }\n  async signUp(request) {\n    // Validate input\n    if (!request.name || !request.email || !request.password) {\n      throw new Error('All fields are required');\n    }\n    if (request.password.length < 6) {\n      throw new Error('Password must be at least 6 characters');\n    }\n    if (!this.isValidEmail(request.email)) {\n      throw new Error('Please enter a valid email address');\n    }\n    if (this.isSupabaseConfigured) {\n      try {\n        var _authData$session;\n        // Use Supabase Auth\n        const {\n          data: authData,\n          error: authError\n        } = await supabase.auth.signUp({\n          email: request.email,\n          password: request.password,\n          options: {\n            data: {\n              name: request.name\n            }\n          }\n        });\n        if (authError) {\n          throw new Error(authError.message);\n        }\n        if (!authData.user) {\n          throw new Error('Failed to create user account');\n        }\n\n        // Create user profile in our custom users table\n        const {\n          error: profileError\n        } = await supabase.from('users').insert({\n          id: authData.user.id,\n          email: request.email,\n          name: request.name\n        });\n        if (profileError) {\n          console.error('Error creating user profile:', profileError);\n          // Don't throw error here as the auth user was created successfully\n        }\n        const user = {\n          id: authData.user.id,\n          email: request.email,\n          name: request.name,\n          createdAt: authData.user.created_at\n        };\n        const response = {\n          user,\n          token: ((_authData$session = authData.session) === null || _authData$session === void 0 ? void 0 : _authData$session.access_token) || ''\n        };\n        return response;\n      } catch (error) {\n        console.error('Supabase signup error:', error);\n        throw error;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockSignUp(request);\n    }\n  }\n  async login(request) {\n    // Validate input\n    if (!request.email || !request.password) {\n      throw new Error('Email and password are required');\n    }\n    if (this.isSupabaseConfigured) {\n      try {\n        // Use Supabase Auth\n        const {\n          data: authData,\n          error: authError\n        } = await supabase.auth.signInWithPassword({\n          email: request.email,\n          password: request.password\n        });\n        if (authError) {\n          throw new Error(authError.message);\n        }\n        if (!authData.user || !authData.session) {\n          throw new Error('Invalid email or password');\n        }\n\n        // Get user profile from our custom users table\n        const {\n          data: userProfile,\n          error: profileError\n        } = await supabase.from('users').select('*').eq('id', authData.user.id).single();\n        if (profileError) {\n          var _authData$user$user_m;\n          console.error('Error fetching user profile:', profileError);\n          // Use auth user data as fallback\n          const user = {\n            id: authData.user.id,\n            email: authData.user.email || '',\n            name: ((_authData$user$user_m = authData.user.user_metadata) === null || _authData$user$user_m === void 0 ? void 0 : _authData$user$user_m.name) || 'User',\n            createdAt: authData.user.created_at\n          };\n          return {\n            user,\n            token: authData.session.access_token\n          };\n        }\n        const user = {\n          id: userProfile.id,\n          email: userProfile.email,\n          name: userProfile.name,\n          createdAt: userProfile.created_at\n        };\n        const response = {\n          user,\n          token: authData.session.access_token\n        };\n        return response;\n      } catch (error) {\n        console.error('Supabase login error:', error);\n        throw error;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockLogin(request);\n    }\n  }\n  async logout() {\n    if (this.isSupabaseConfigured) {\n      try {\n        // Use Supabase Auth logout\n        const {\n          error\n        } = await supabase.auth.signOut();\n        if (error) {\n          console.error('Supabase logout error:', error);\n        }\n      } catch (error) {\n        console.error('Supabase logout error:', error);\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      await new Promise(resolve => setTimeout(resolve, 500));\n    }\n  }\n  async getCurrentUser() {\n    if (this.isSupabaseConfigured) {\n      try {\n        // Get current session from Supabase\n        const {\n          data: {\n            session\n          },\n          error\n        } = await supabase.auth.getSession();\n        if (error) {\n          console.error('Error getting session:', error);\n          return null;\n        }\n        if (!(session !== null && session !== void 0 && session.user)) {\n          return null;\n        }\n\n        // Get user profile from our custom users table\n        const {\n          data: userProfile,\n          error: profileError\n        } = await supabase.from('users').select('*').eq('id', session.user.id).single();\n        if (profileError) {\n          var _session$user$user_me;\n          console.error('Error fetching user profile:', profileError);\n          // Use auth user data as fallback\n          return {\n            id: session.user.id,\n            email: session.user.email || '',\n            name: ((_session$user$user_me = session.user.user_metadata) === null || _session$user$user_me === void 0 ? void 0 : _session$user$user_me.name) || 'User',\n            createdAt: session.user.created_at\n          };\n        }\n        return {\n          id: userProfile.id,\n          email: userProfile.email,\n          name: userProfile.name,\n          createdAt: userProfile.created_at\n        };\n      } catch (error) {\n        console.error('Supabase getCurrentUser error:', error);\n        return null;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockGetCurrentUser();\n    }\n  }\n  async refreshToken() {\n    if (this.isSupabaseConfigured) {\n      try {\n        // Supabase handles token refresh automatically\n        const {\n          data: {\n            session\n          },\n          error\n        } = await supabase.auth.getSession();\n        if (error || !session) {\n          return null;\n        }\n        return session.access_token;\n      } catch (error) {\n        console.error('Supabase refreshToken error:', error);\n        return null;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockRefreshToken();\n    }\n  }\n\n  // Mock fallback methods\n  async mockSignUp(request) {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Check if user already exists\n    const existingUser = this.mockUsers.find(user => user.email === request.email);\n    if (existingUser) {\n      throw new Error('User with this email already exists');\n    }\n\n    // Create new user\n    const newUser = {\n      id: (this.mockUsers.length + 1).toString(),\n      email: request.email,\n      name: request.name,\n      createdAt: new Date().toISOString()\n    };\n\n    // Add to mock database\n    this.mockUsers.push(newUser);\n\n    // Generate mock token\n    const token = this.generateMockToken(newUser.id);\n    return {\n      user: newUser,\n      token\n    };\n  }\n  async mockLogin(request) {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // For demo purposes, accept any password for demo@example.com\n    if (request.email === 'demo@example.com') {\n      const user = this.mockUsers.find(u => u.email === request.email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n      const token = this.generateMockToken(user.id);\n      return {\n        user,\n        token\n      };\n    }\n\n    // Find user in mock database\n    const user = this.mockUsers.find(u => u.email === request.email);\n    if (!user) {\n      throw new Error('Invalid email or password');\n    }\n\n    // In a real app, you would verify the password hash here\n    // For demo purposes, we'll accept any password\n    const token = this.generateMockToken(user.id);\n    return {\n      user,\n      token\n    };\n  }\n  async mockGetCurrentUser() {\n    await new Promise(resolve => setTimeout(resolve, 300));\n\n    // Return demo user for mock mode\n    return this.mockUsers[0];\n  }\n  async mockRefreshToken() {\n    const currentUser = await this.mockGetCurrentUser();\n    if (!currentUser) {\n      return null;\n    }\n    return this.generateMockToken(currentUser.id);\n  }\n  generateMockToken(userId) {\n    // In a real app, this would be generated by the server\n    const payload = {\n      userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + 24 * 60 * 60 // 24 hours\n    };\n    return btoa(JSON.stringify(payload));\n  }\n  isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Get auth data from localStorage (synchronous)\n  getStoredAuth() {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n    try {\n      return JSON.parse(stored);\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      return null;\n    }\n  }\n  storeAuth(authData) {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n  }\n  clearAuth() {\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n}\nexport default new AuthService();","map":{"version":3,"names":["AuthService","constructor","STORAGE_KEY","mockUsers","id","email","name","createdAt","isSupabaseConfigured","process","env","REACT_APP_SUPABASE_URL","REACT_APP_SUPABASE_ANON_KEY","signUp","request","password","Error","length","isValidEmail","_authData$session","data","authData","error","authError","supabase","auth","options","message","user","profileError","from","insert","console","created_at","response","token","session","access_token","warn","mockSignUp","login","signInWithPassword","userProfile","select","eq","single","_authData$user$user_m","user_metadata","mockLogin","logout","signOut","Promise","resolve","setTimeout","getCurrentUser","getSession","_session$user$user_me","mockGetCurrentUser","refreshToken","mockRefreshToken","existingUser","find","newUser","toString","Date","toISOString","push","generateMockToken","u","currentUser","userId","payload","iat","Math","floor","now","exp","btoa","JSON","stringify","emailRegex","test","getStoredAuth","stored","localStorage","getItem","parse","storeAuth","setItem","clearAuth","removeItem"],"sources":["/Users/hanngn/Documents/CreditScorecerer/credit-scorecerer/Web/src/services/AuthService.ts"],"sourcesContent":["import { AuthUser, LoginRequest, SignUpRequest, AuthResponse } from '../types';\n// import { supabase } from '../config/supabase';\n\nclass AuthService {\n  private readonly STORAGE_KEY = 'credit_scorecerer_auth';\n\n  // Check if Supabase is configured\n  private get isSupabaseConfigured(): boolean {\n    return !!(process.env.REACT_APP_SUPABASE_URL && process.env.REACT_APP_SUPABASE_ANON_KEY);\n  }\n\n  // Fallback mock user database\n  private mockUsers: AuthUser[] = [\n    {\n      id: '1',\n      email: 'demo@example.com',\n      name: 'Demo User',\n      createdAt: '2024-01-01T00:00:00Z'\n    }\n  ];\n\n  async signUp(request: SignUpRequest): Promise<AuthResponse> {\n    // Validate input\n    if (!request.name || !request.email || !request.password) {\n      throw new Error('All fields are required');\n    }\n\n    if (request.password.length < 6) {\n      throw new Error('Password must be at least 6 characters');\n    }\n\n    if (!this.isValidEmail(request.email)) {\n      throw new Error('Please enter a valid email address');\n    }\n\n    if (this.isSupabaseConfigured) {\n      try {\n        // Use Supabase Auth\n        const { data: authData, error: authError } = await supabase.auth.signUp({\n          email: request.email,\n          password: request.password,\n          options: {\n            data: {\n              name: request.name\n            }\n          }\n        });\n\n        if (authError) {\n          throw new Error(authError.message);\n        }\n\n        if (!authData.user) {\n          throw new Error('Failed to create user account');\n        }\n\n        // Create user profile in our custom users table\n        const { error: profileError } = await supabase\n          .from('users')\n          .insert({\n            id: authData.user.id,\n            email: request.email,\n            name: request.name\n          });\n\n        if (profileError) {\n          console.error('Error creating user profile:', profileError);\n          // Don't throw error here as the auth user was created successfully\n        }\n\n        const user: AuthUser = {\n          id: authData.user.id,\n          email: request.email,\n          name: request.name,\n          createdAt: authData.user.created_at\n        };\n\n        const response: AuthResponse = {\n          user,\n          token: authData.session?.access_token || ''\n        };\n\n        return response;\n      } catch (error) {\n        console.error('Supabase signup error:', error);\n        throw error;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockSignUp(request);\n    }\n  }\n\n  async login(request: LoginRequest): Promise<AuthResponse> {\n    // Validate input\n    if (!request.email || !request.password) {\n      throw new Error('Email and password are required');\n    }\n\n    if (this.isSupabaseConfigured) {\n      try {\n        // Use Supabase Auth\n        const { data: authData, error: authError } = await supabase.auth.signInWithPassword({\n          email: request.email,\n          password: request.password\n        });\n\n        if (authError) {\n          throw new Error(authError.message);\n        }\n\n        if (!authData.user || !authData.session) {\n          throw new Error('Invalid email or password');\n        }\n\n        // Get user profile from our custom users table\n        const { data: userProfile, error: profileError } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', authData.user.id)\n          .single();\n\n        if (profileError) {\n          console.error('Error fetching user profile:', profileError);\n          // Use auth user data as fallback\n          const user: AuthUser = {\n            id: authData.user.id,\n            email: authData.user.email || '',\n            name: authData.user.user_metadata?.name || 'User',\n            createdAt: authData.user.created_at\n          };\n\n          return {\n            user,\n            token: authData.session.access_token\n          };\n        }\n\n        const user: AuthUser = {\n          id: userProfile.id,\n          email: userProfile.email,\n          name: userProfile.name,\n          createdAt: userProfile.created_at\n        };\n\n        const response: AuthResponse = {\n          user,\n          token: authData.session.access_token\n        };\n\n        return response;\n      } catch (error) {\n        console.error('Supabase login error:', error);\n        throw error;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockLogin(request);\n    }\n  }\n\n  async logout(): Promise<void> {\n    if (this.isSupabaseConfigured) {\n      try {\n        // Use Supabase Auth logout\n        const { error } = await supabase.auth.signOut();\n        if (error) {\n          console.error('Supabase logout error:', error);\n        }\n      } catch (error) {\n        console.error('Supabase logout error:', error);\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      await new Promise(resolve => setTimeout(resolve, 500));\n    }\n  }\n\n  async getCurrentUser(): Promise<AuthUser | null> {\n    if (this.isSupabaseConfigured) {\n      try {\n        // Get current session from Supabase\n        const { data: { session }, error } = await supabase.auth.getSession();\n        \n        if (error) {\n          console.error('Error getting session:', error);\n          return null;\n        }\n\n        if (!session?.user) {\n          return null;\n        }\n\n        // Get user profile from our custom users table\n        const { data: userProfile, error: profileError } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', session.user.id)\n          .single();\n\n        if (profileError) {\n          console.error('Error fetching user profile:', profileError);\n          // Use auth user data as fallback\n          return {\n            id: session.user.id,\n            email: session.user.email || '',\n            name: session.user.user_metadata?.name || 'User',\n            createdAt: session.user.created_at\n          };\n        }\n\n        return {\n          id: userProfile.id,\n          email: userProfile.email,\n          name: userProfile.name,\n          createdAt: userProfile.created_at\n        };\n      } catch (error) {\n        console.error('Supabase getCurrentUser error:', error);\n        return null;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockGetCurrentUser();\n    }\n  }\n\n  async refreshToken(): Promise<string | null> {\n    if (this.isSupabaseConfigured) {\n      try {\n        // Supabase handles token refresh automatically\n        const { data: { session }, error } = await supabase.auth.getSession();\n        \n        if (error || !session) {\n          return null;\n        }\n\n        return session.access_token;\n      } catch (error) {\n        console.error('Supabase refreshToken error:', error);\n        return null;\n      }\n    } else {\n      // Fallback to mock implementation\n      console.warn('Supabase not configured, using mock authentication');\n      return this.mockRefreshToken();\n    }\n  }\n\n  // Mock fallback methods\n  private async mockSignUp(request: SignUpRequest): Promise<AuthResponse> {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Check if user already exists\n    const existingUser = this.mockUsers.find(user => user.email === request.email);\n    if (existingUser) {\n      throw new Error('User with this email already exists');\n    }\n\n    // Create new user\n    const newUser: AuthUser = {\n      id: (this.mockUsers.length + 1).toString(),\n      email: request.email,\n      name: request.name,\n      createdAt: new Date().toISOString()\n    };\n\n    // Add to mock database\n    this.mockUsers.push(newUser);\n\n    // Generate mock token\n    const token = this.generateMockToken(newUser.id);\n\n    return {\n      user: newUser,\n      token\n    };\n  }\n\n  private async mockLogin(request: LoginRequest): Promise<AuthResponse> {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // For demo purposes, accept any password for demo@example.com\n    if (request.email === 'demo@example.com') {\n      const user = this.mockUsers.find(u => u.email === request.email);\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      const token = this.generateMockToken(user.id);\n      return {\n        user,\n        token\n      };\n    }\n\n    // Find user in mock database\n    const user = this.mockUsers.find(u => u.email === request.email);\n    if (!user) {\n      throw new Error('Invalid email or password');\n    }\n\n    // In a real app, you would verify the password hash here\n    // For demo purposes, we'll accept any password\n    const token = this.generateMockToken(user.id);\n    return {\n      user,\n      token\n    };\n  }\n\n  private async mockGetCurrentUser(): Promise<AuthUser | null> {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    \n    // Return demo user for mock mode\n    return this.mockUsers[0];\n  }\n\n  private async mockRefreshToken(): Promise<string | null> {\n    const currentUser = await this.mockGetCurrentUser();\n    if (!currentUser) {\n      return null;\n    }\n\n    return this.generateMockToken(currentUser.id);\n  }\n\n  private generateMockToken(userId: string): string {\n    // In a real app, this would be generated by the server\n    const payload = {\n      userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours\n    };\n    \n    return btoa(JSON.stringify(payload));\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // Get auth data from localStorage (synchronous)\n  getStoredAuth(): AuthResponse | null {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(stored);\n    } catch (error) {\n      console.error('Error parsing stored auth data:', error);\n      return null;\n    }\n  }\n\n  private storeAuth(authData: AuthResponse): void {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(authData));\n  }\n\n  private clearAuth(): void {\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n}\n\nexport default new AuthService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}